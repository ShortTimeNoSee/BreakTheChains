<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<!-- Set a fixed viewport width to mimic desktop view on mobile devices -->
<meta name="viewport" content="width=1024"/>
<link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<link rel="shortcut icon" href="favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png" />
<meta name="apple-mobile-web-app-title" content="BreakTheChains" />
<link rel="manifest" href="site.webmanifest" />
<title>Break the Chains</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700;900&display=swap" rel="stylesheet">

<style>
html, body {
 margin:0; padding:0;
 font-family:'Montserrat',sans-serif;
 background:#111;
 color:#fff;
 overflow-x:hidden;
 scroll-behavior:smooth;
}
body {
 min-height:100vh;
}
.section {
 position:relative;
 width:100%;
 min-height:100vh;
 display:flex;
 flex-direction:column;
 justify-content:center;
 align-items:center;
 padding:4rem 2rem;
 text-align:center;
}
h1,h2,h3,p {
 margin:0.5rem 0; line-height:1.4;
}
h1 {font-size:3rem; font-weight:900; letter-spacing:0.05em;}
h2 {font-size:2rem; font-weight:700;}
p {font-size:1rem; font-weight:300; max-width:700px; margin:0.5rem auto;}
#titleSection {
 background:#000;
 overflow:hidden;
 position:relative;
}
#titleSection h1 {
 font-size:4rem;
 margin-bottom:1rem;
}
#titleSection p {
 font-size:1.2rem;
 color:#aaa;
}
.act {
 background-size:cover;
 background-position:center;
 background-attachment:fixed;
 background-repeat:no-repeat;
}
#actI {background-image:url('middle_passage.jpg');}
#actII {background-image:url('civil_rights.jpg');}
#actIII {background-image:url('entrepreneurship.jpg');}
.section-overlay {
 background:rgba(0,0,0,0.5);
 padding:2rem;
 border-radius:8px;
}
.hover-layer {
 position:absolute;
 height: fit-content; width: 20vw;
 padding: 5px;
 background:rgba(0,0,0,0.8);
 display:flex;align-items:center;justify-content:center;flex-direction:column;
 opacity:0;pointer-events:none;
 transition:opacity 0.4s ease;
}
.hover-trigger {
 position:relative;
}
.hover-trigger:hover .hover-layer {
 opacity:1;pointer-events:all;
}
#particleSection {
 position:relative;
 background:#000;
 display:flex;
 flex-direction:column;
 justify-content:center;
 align-items:center;
 overflow:hidden;
 min-height:100vh;
}
#particleCanvas {
 position:absolute;
 top:0;
 left:0;
 width:100%;
 height:100%;
 z-index:1;
}
#footer {
 background:#111;
 padding:2rem;
 text-align:center;
 font-size:0.9rem;
 color:#ccc;
}

.start-audio-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.8);
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    font-size: 16px;
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
}

@media (hover: none) and (pointer: coarse) {
    .start-audio-btn {
        width: 40vw;
        height: 6vw;
        padding: 0;
        line-height: 6vw;
        font-size: 2.5vw;
        display: flex;
        align-items: center;
        justify-content: center;
        right: 50%;
        transform: translateX(50%);
    }
}

.start-audio-btn.visible {
  opacity: 1;
  pointer-events: all;
}

.start-audio-btn:hover {
  background: rgba(255,255,255,0.2);
}

/* Removed media queries to maintain desktop-like appearance on all devices */
/*
@media (max-width:600px){
 h1 {font-size:2rem;}
 h2 {font-size:1.5rem;}
 #titleSection h1 {font-size:3rem;}
}
*/
</style>
</head>
<body>

<button id="startAudioBtn" class="start-audio-btn">Enable Audio</button>

<audio id="audioWaves" src="waves.mp3" preload="auto" loop></audio>
<audio id="audioChants" src="protest_chants.wav" preload="auto" loop></audio>
<audio id="audioDrums" src="african_drums.mp3" preload="auto" loop></audio>

<section id="titleSection" class="section">
 <div class="section-overlay">
   <h1>Break the Chains</h1>
   <p>From bondage to self-determination: A journey through oppression, resilience, and collective empowerment.</p>
 </div>
</section>

<section id="actI" class="section act">
 <div class="section-overlay">
   <h2>Act I: Shackled Past</h2>
   <p>The transatlantic slave trade forced millions into brutal conditions. Families torn apart, identities suppressed, futures stolen.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;"><u>MORE</u></p>
     <div class="hover-layer">
       <h3>Deconstruction of a Legacy</h3>
       <p>Documents, logs, auctions. Yet resilience persisted in whispered prayers, hidden traditions, coded songs.</p>
     </div>
   </div>
 </div>
</section>

<section id="actII" class="section act">
 <div class="section-overlay">
   <h2>Act II: The Long Fight</h2>
   <p>From Reconstruction through Civil Rights, rights were demanded and seized, not granted.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;"><u>MORE</u></p>
     <div class="hover-layer">
       <h3>The Chorus of Resistance</h3>
       <p>Protests, marches, boycotts. Affirmations of worth reclaimed by collective action.</p>
     </div>
   </div>
 </div>
</section>

<section id="actIII" class="section act">
 <div class="section-overlay">
   <h2>Act III: Unbroken Paths</h2>
   <p>Modern innovators shape their futures, building prosperity and cultural wealth from within.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;"><u>MORE</u></p>
     <div class="hover-layer">
       <h3>Self-Determined Futures</h3>
       <p>Sustainable progress arises from internal community strength.</p>
     </div>
   </div>
 </div>
</section>

<section id="particleSection" class="section">
 <canvas id="particleCanvas"></canvas>
</section>

<footer id="footer">
 <p>Images & Audio: Public Domain or Freely Licensed<br/>Nicholas A. Thompson</p>
</footer>

<script>
gsap.registerPlugin(ScrollTrigger);

// Audio setup
const wavesAudio = document.getElementById('audioWaves');
const chantsAudio = document.getElementById('audioChants');
const drumsAudio = document.getElementById('audioDrums');
const startAudioBtn = document.getElementById('startAudioBtn');

[wavesAudio, chantsAudio, drumsAudio].forEach(audio => {
    audio.volume = 0;
});

let audioInitialized = false;
let audioAttempts = 0;
const MAX_AUTO_ATTEMPTS = 3;

// Show button after delay if audio hasn't started
setTimeout(() => {
    if (!audioInitialized) {
        startAudioBtn.classList.add('visible');
    }
}, 2000);

async function initializeAudio() {
    if (audioInitialized) return;
    
    try {
        // Try to start all audio tracks simultaneously
        await Promise.all([
            wavesAudio.play(),
            chantsAudio.play(),
            drumsAudio.play()
        ]);
        
        audioInitialized = true;
        startAudioBtn.classList.remove('visible');
        console.log('Audio initialized successfully');
        updateAudioBasedOnVisibility();
        
    } catch (error) {
        console.log('Audio initialization attempt failed:', error);
        audioAttempts++;
        
        if (audioAttempts >= MAX_AUTO_ATTEMPTS) {
            startAudioBtn.classList.add('visible');
        }
    }
}

// Button click handler
startAudioBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    await initializeAudio();
});

// Try to initialize on various user interactions
const interactionEvents = ['click', 'touchstart', 'scroll', 'keydown'];
interactionEvents.forEach(event => {
    document.addEventListener(event, initializeAudio, { once: true });
});

// Try to initialize on visibility change
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        initializeAudio();
    }
});

// Try to initialize on window focus
window.addEventListener('focus', initializeAudio);

// Try to initialize after a delay
setTimeout(initializeAudio, 1000);

// Try to initialize on mouse movement
let mouseMoveDebounce;
document.addEventListener('mousemove', () => {
    if (!audioInitialized && !mouseMoveDebounce) {
        mouseMoveDebounce = setTimeout(() => {
            initializeAudio();
            mouseMoveDebounce = null;
        }, 500);
    }
});

// Try to initialize on scroll with debounce
let scrollDebounce;
document.addEventListener('scroll', () => {
    if (!audioInitialized && !scrollDebounce) {
        scrollDebounce = setTimeout(() => {
            initializeAudio();
            scrollDebounce = null;
        }, 500);
    }
}, { passive: true });

// Calculate which section is most visible
function getVisiblePercentage(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    
    // If the element is not in view at all
    if (rect.bottom < 0 || rect.top > windowHeight) {
        return 0;
    }
    
    const visibleTop = Math.max(0, rect.top);
    const visibleBottom = Math.min(windowHeight, rect.bottom);
    const visibleHeight = visibleBottom - visibleTop;
    
    return (visibleHeight / windowHeight) * 100;
}

function getMostVisibleSection() {
    const sections = {
        waves: [
            document.getElementById('titleSection'),
            document.getElementById('actI')
        ],
        chants: [
            document.getElementById('actII')
        ],
        drums: [
            document.getElementById('actIII'),
            document.getElementById('particleSection')
        ]
    };

    let maxVisibility = {
        waves: Math.max(...sections.waves.map(getVisiblePercentage)),
        chants: Math.max(...sections.chants.map(getVisiblePercentage)),
        drums: Math.max(...sections.drums.map(getVisiblePercentage))
    };

    // Find the largest visible section
    let maxValue = Math.max(...Object.values(maxVisibility));
    
    // Return the corresponding section type
    return maxValue > 20 ? 
           Object.entries(maxVisibility).find(([_, value]) => value === maxValue)[0] 
           : null;
}

function updateAudioBasedOnVisibility() {
    if (!audioInitialized) return;

    const dominantSection = getMostVisibleSection();
    console.log('Dominant section:', dominantSection);

    // Set target volumes
    let targets = {
        waves: dominantSection === 'waves' ? 1 : 0,
        chants: dominantSection === 'chants' ? 1 : 0,
        drums: dominantSection === 'drums' ? 1 : 0
    };

    // First set immediate volumes
    wavesAudio.volume = targets.waves;
    chantsAudio.volume = targets.chants;
    drumsAudio.volume = targets.drums;

    // Then do smooth transitions
    gsap.to(wavesAudio, { volume: targets.waves, duration: 0.5 });
    gsap.to(chantsAudio, { volume: targets.chants, duration: 0.5 });
    gsap.to(drumsAudio, { volume: targets.drums, duration: 0.5 });
}

// Handle scroll events with throttling
let scrollTimeout;
window.addEventListener('scroll', () => {
    if (!scrollTimeout) {
        scrollTimeout = setTimeout(() => {
            updateAudioBasedOnVisibility();
            scrollTimeout = null;
        }, 100);
    }
});

// Handle window resize
window.addEventListener('resize', updateAudioBasedOnVisibility);

// Particle system setup
const quoteLines = [
    '"I prayed for twenty years but',
    'received no answer until',
    'I prayed with my legs."',
    '– Frederick Douglass'
];

// Canvas setup
const canvas = document.getElementById('particleCanvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

// Handle window resize for canvas
window.addEventListener('resize', () => {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    prepareTextPoints();
    resetParticles();
});

// Text points preparation
let textPoints = [];
function prepareTextPoints() {
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    offCanvas.width = W;
    offCanvas.height = H;
    
    // Clear background
    offCtx.fillStyle = '#000';
    offCtx.fillRect(0, 0, W, H);
    
    // Setup text
    const fontSize = Math.min(W/15, 40);
    offCtx.font = `bold ${fontSize}px Montserrat`;
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    
    // Calculate text positioning
    const lineHeight = fontSize * 1.3;
    const totalHeight = lineHeight * quoteLines.length;
    const startY = H/2 - totalHeight/2;
    
    // Draw text
    offCtx.fillStyle = '#fff';
    quoteLines.forEach((line, i) => {
        offCtx.fillText(line, W/2, startY + i*lineHeight);
    });
    
    // Extract points
    const imageData = offCtx.getImageData(0, 0, W, H).data;
    textPoints = [];
    const step = 3;
    
    for (let y = 0; y < H; y += step) {
        for (let x = 0; x < W; x += step) {
            if (imageData[(y*W + x)*4] > 200) {
                textPoints.push({x, y});
            }
        }
    }
}

// Initialize text points
prepareTextPoints();

// Particle system
const particles = [];
const numParticles = Math.min(2500, textPoints.length);
const centerX = W/2;
const centerY = H/2;

function resetParticles() {
    particles.length = 0;
    for (let i = 0; i < textPoints.length; i++) { // Match the number of particles to textPoints
        particles.push({
            x: centerX + (Math.random() * 10 - 5),
            y: centerY + (Math.random() * 10 - 5),
            vx: 0,
            vy: 0,
            targetIndex: i // Each particle has a corresponding target point
        });
    }
}

resetParticles();

// Animation phases
let phase = 'clumped';
let particlesReady = false;
let interacted = false;

ScrollTrigger.create({
    trigger: "#particleSection",
    start: "top center",
    onEnter: () => {
        particlesReady = true;
    }
});

// Phase transitions
function startScatter() {
    if (phase !== 'clumped') return;
    phase = 'scatter';
    particles.forEach(p => {
        p.vx = (Math.random()-0.5)*20;
        p.vy = (Math.random()-0.5)*20;
    });
    setTimeout(startSwirl, 1500);
}

function startSwirl() {
    if (phase !== 'scatter') return;
    phase = 'swirl';
    setTimeout(formText, 2000);
}

function formText() {
    if (phase !== 'swirl') return;
    phase = 'form';
    particles.forEach((p, i) => {
        p.targetIndex = i % textPoints.length;
    });
}

// Interaction handling
function onParticleInteract() {
    if (!particlesReady || interacted) return;
    interacted = true;
    startScatter();
}

document.getElementById('particleSection').addEventListener('mousemove', onParticleInteract);
document.getElementById('particleSection').addEventListener('touchstart', onParticleInteract);
document.getElementById('particleSection').addEventListener('click', onParticleInteract);

// Animation loop
function animate() {
    ctx.clearRect(0, 0, W, H);
    
    particles.forEach(p => {
        ctx.fillStyle = '#f00';
        
        switch(phase) {
            case 'clumped':
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'scatter':
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'swirl':
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                p.vx += -Math.sin(angle)*0.5;
                p.vy += Math.cos(angle)*0.5;
                
                const pull = (200 - dist)*0.002;
                if (pull > 0) {
                    p.vx -= dx*pull;
                    p.vy -= dy*pull;
                }
                
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.x += p.vx;
                p.y += p.vy;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'form':
                const target = textPoints[p.targetIndex];
                const tdx = target.x - p.x;
                const tdy = target.y - p.y;
                p.vx += tdx*0.02;
                p.vy += tdy*0.02;
                p.vx *= 0.8;
                p.vy *= 0.8;
                p.x += p.vx;
                p.y += p.vy;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
        }
    });
    
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
