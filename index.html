<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Break the Chains</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;700;900&display=swap" rel="stylesheet">

<style>
html, body {
 margin:0; padding:0;
 font-family:'Montserrat',sans-serif;
 background:#111;
 color:#fff;
 overflow-x:hidden;
 scroll-behavior:smooth;
}
body {
 min-height:100vh;
}
.section {
 position:relative;
 width:100%;
 min-height:100vh;
 display:flex;
 flex-direction:column;
 justify-content:center;
 align-items:center;
 padding:4rem 2rem;
 text-align:center;
}
h1,h2,h3,p {
 margin:0.5rem 0; line-height:1.4;
}
h1 {font-size:3rem; font-weight:900; letter-spacing:0.05em;}
h2 {font-size:2rem; font-weight:700;}
p {font-size:1rem; font-weight:300; max-width:700px; margin:0.5rem auto;}
#titleSection {
 background:#000;
 overflow:hidden;
 position:relative;
}
#titleSection h1 {
 font-size:4rem;
 margin-bottom:1rem;
}
#titleSection p {
 font-size:1.2rem;
 color:#aaa;
}
.act {
 background-size:cover;
 background-position:center;
 background-attachment:fixed;
 background-repeat:no-repeat;
}
#actI {background-image:url('middle_passage.jpg');}
#actII {background-image:url('civil_rights.jpg');}
#actIII {background-image:url('entrepreneurship.jpg');}
.section-overlay {
 background:rgba(0,0,0,0.5);
 padding:2rem;
 border-radius:8px;
}
.hover-layer {
 position:absolute;top:0;left:0;right:0;bottom:0;
 height: fit-content;
 padding: 5px;
 background:rgba(0,0,0,0.8);
 display:flex;align-items:center;justify-content:center;flex-direction:column;
 opacity:0;pointer-events:none;
 transition:opacity 0.4s ease;
}
.hover-trigger {
 position:relative;
}
.hover-trigger:hover .hover-layer {
 opacity:1;pointer-events:all;
}
#particleSection {
 position:relative;
 background:#000;
 display:flex;
 flex-direction:column;
 justify-content:center;
 align-items:center;
 overflow:hidden;
 min-height:100vh;
}
#particleCanvas {
 position:absolute;
 top:0;
 left:0;
 width:100%;
 height:100%;
 z-index:1;
}
#footer {
 background:#111;
 padding:2rem;
 text-align:center;
 font-size:0.9rem;
 color:#ccc;
}
@media (max-width:600px){
 h1 {font-size:2rem;}
 h2 {font-size:1.5rem;}
 #titleSection h1 {font-size:3rem;}
}
</style>
</head>
<body>

<audio id="audioWaves" src="waves.mp3" preload="auto" loop></audio>
<audio id="audioChants" src="protest_chants.wav" preload="auto" loop></audio>
<audio id="audioDrums" src="african_drums.mp3" preload="auto" loop></audio>

<section id="titleSection" class="section">
 <div class="section-overlay">
   <h1>Break the Chains</h1>
   <p>From bondage to self-determination: A journey through oppression, resilience, and collective empowerment.</p>
 </div>
</section>

<section id="actI" class="section act">
 <div class="section-overlay">
   <h2>Act I: Shackled Past</h2>
   <p>The transatlantic slave trade forced millions into brutal conditions. Families torn apart, identities suppressed, futures stolen.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;">Hover to Reveal the Layers of History</p>
     <div class="hover-layer">
       <h3>Deconstruction of a Legacy</h3>
       <p>Documents, logs, auctions. Yet resilience persisted in whispered prayers, hidden traditions, coded songs.</p>
     </div>
   </div>
 </div>
</section>

<section id="actII" class="section act">
 <div class="section-overlay">
   <h2>Act II: The Long Fight</h2>
   <p>From Reconstruction through Civil Rights, rights were demanded and seized, not granted.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;">Hover for the Rising Voices</p>
     <div class="hover-layer">
       <h3>The Chorus of Resistance</h3>
       <p>Protests, marches, boycotts. Affirmations of worth reclaimed by collective action.</p>
     </div>
   </div>
 </div>
</section>

<section id="actIII" class="section act">
 <div class="section-overlay">
   <h2>Act III: Unbroken Paths</h2>
   <p>Modern innovators shape their futures, building prosperity and cultural wealth from within.</p>
   <div class="hover-trigger" style="margin-top:2rem;display:inline-block;">
     <p style="font-weight:700;">Hover to See Economic Sparks</p>
     <div class="hover-layer">
       <h3>Self-Determined Futures</h3>
       <p>Sustainable progress arises from internal community strength.</p>
     </div>
   </div>
 </div>
</section>

<section id="particleSection" class="section">
 <canvas id="particleCanvas"></canvas>
</section>

<footer id="footer">
 <p>Images & Audio: Public Domain or Freely Licensed<br/>Nicholas A. Thompson</p>
</footer>

<script>
gsap.registerPlugin(ScrollTrigger);

// Audio setup
const wavesAudio = document.getElementById('audioWaves');
const chantsAudio = document.getElementById('audioChants');
const drumsAudio = document.getElementById('audioDrums');

[wavesAudio, chantsAudio, drumsAudio].forEach(audio => {
    audio.volume = 0;
});

let audioInitialized = false;

async function initializeAudio() {
    if (audioInitialized) return;
    
    try {
        await Promise.all([
            wavesAudio.play(),
            chantsAudio.play(),
            drumsAudio.play()
        ]);
        
        audioInitialized = true;
        console.log('Audio initialized');
        updateAudioBasedOnVisibility();
    } catch (error) {
        console.log('Audio initialization failed:', error);
    }
}

// Add multiple chances to initialize audio
document.addEventListener('click', initializeAudio);
document.addEventListener('touchstart', initializeAudio);
document.addEventListener('scroll', initializeAudio);

// Calculate which section is most visible
function getVisiblePercentage(element) {
    const rect = element.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    
    // If the element is not in view at all
    if (rect.bottom < 0 || rect.top > windowHeight) {
        return 0;
    }
    
    const visibleTop = Math.max(0, rect.top);
    const visibleBottom = Math.min(windowHeight, rect.bottom);
    const visibleHeight = visibleBottom - visibleTop;
    
    return (visibleHeight / windowHeight) * 100;
}

function getMostVisibleSection() {
    const sections = {
        waves: [
            document.getElementById('titleSection'),
            document.getElementById('actI')
        ],
        chants: [
            document.getElementById('actII')
        ],
        drums: [
            document.getElementById('actIII'),
            document.getElementById('particleSection')
        ]
    };

    let maxVisibility = {
        waves: Math.max(...sections.waves.map(getVisiblePercentage)),
        chants: Math.max(...sections.chants.map(getVisiblePercentage)),
        drums: Math.max(...sections.drums.map(getVisiblePercentage))
    };

    // Find the largest visible section
    let maxValue = Math.max(...Object.values(maxVisibility));
    
    // Return the corresponding section type
    return maxValue > 20 ? 
           Object.entries(maxVisibility).find(([_, value]) => value === maxValue)[0] 
           : null;
}

function updateAudioBasedOnVisibility() {
    if (!audioInitialized) return;

    const dominantSection = getMostVisibleSection();
    console.log('Dominant section:', dominantSection);

    // Set target volumes
    let targets = {
        waves: dominantSection === 'waves' ? 1 : 0,
        chants: dominantSection === 'chants' ? 1 : 0,
        drums: dominantSection === 'drums' ? 1 : 0
    };

    // First set immediate volumes
    wavesAudio.volume = targets.waves;
    chantsAudio.volume = targets.chants;
    drumsAudio.volume = targets.drums;

    // Then do smooth transitions
    gsap.to(wavesAudio, { volume: targets.waves, duration: 0.5 });
    gsap.to(chantsAudio, { volume: targets.chants, duration: 0.5 });
    gsap.to(drumsAudio, { volume: targets.drums, duration: 0.5 });
}

// Handle scroll events with throttling
let scrollTimeout;
window.addEventListener('scroll', () => {
    if (!scrollTimeout) {
        scrollTimeout = setTimeout(() => {
            updateAudioBasedOnVisibility();
            scrollTimeout = null;
        }, 100);
    }
});

// Handle window resize
window.addEventListener('resize', updateAudioBasedOnVisibility);

// Particle system setup
const quoteLines = [
    '"I prayed for twenty years but',
    'received no answer until',
    'I prayed with my legs."',
    'â€“ Frederick Douglass'
];

// Canvas setup
const canvas = document.getElementById('particleCanvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

// Handle window resize for canvas
window.addEventListener('resize', () => {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    prepareTextPoints();
    resetParticles();
});

// Text points preparation
let textPoints = [];
function prepareTextPoints() {
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    offCanvas.width = W;
    offCanvas.height = H;
    
    // Clear background
    offCtx.fillStyle = '#000';
    offCtx.fillRect(0, 0, W, H);
    
    // Setup text
    const fontSize = Math.min(W/15, 40);
    offCtx.font = `bold ${fontSize}px Montserrat`;
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    
    // Calculate text positioning
    const lineHeight = fontSize * 1.3;
    const totalHeight = lineHeight * quoteLines.length;
    const startY = H/2 - totalHeight/2;
    
    // Draw text
    offCtx.fillStyle = '#fff';
    quoteLines.forEach((line, i) => {
        offCtx.fillText(line, W/2, startY + i*lineHeight);
    });
    
    // Extract points
    const imageData = offCtx.getImageData(0, 0, W, H).data;
    textPoints = [];
    const step = 3;
    
    for (let y = 0; y < H; y += step) {
        for (let x = 0; x < W; x += step) {
            if (imageData[(y*W + x)*4] > 200) {
                textPoints.push({x, y});
            }
        }
    }
}

// Initialize text points
prepareTextPoints();

// Particle system
const particles = [];
const numParticles = Math.min(2500, textPoints.length);
const centerX = W/2;
const centerY = H/2;

function resetParticles() {
    particles.length = 0;
    for (let i = 0; i < numParticles; i++) {
        particles.push({
            x: centerX + (Math.random()*10-5),
            y: centerY + (Math.random()*10-5),
            vx: 0,
            vy: 0,
            targetIndex: null
        });
    }
}

resetParticles();

// Animation phases
let phase = 'clumped';
let particlesReady = false;
let interacted = false;

ScrollTrigger.create({
    trigger: "#particleSection",
    start: "top center",
    onEnter: () => {
        particlesReady = true;
    }
});

// Phase transitions
function startScatter() {
    if (phase !== 'clumped') return;
    phase = 'scatter';
    particles.forEach(p => {
        p.vx = (Math.random()-0.5)*20;
        p.vy = (Math.random()-0.5)*20;
    });
    setTimeout(startSwirl, 1500);
}

function startSwirl() {
    if (phase !== 'scatter') return;
    phase = 'swirl';
    setTimeout(formText, 2000);
}

function formText() {
    if (phase !== 'swirl') return;
    phase = 'form';
    particles.forEach((p, i) => {
        p.targetIndex = i % textPoints.length;
    });
}

// Interaction handling
function onParticleInteract() {
    if (!particlesReady || interacted) return;
    interacted = true;
    startScatter();
}

document.getElementById('particleSection').addEventListener('mousemove', onParticleInteract);
document.getElementById('particleSection').addEventListener('touchstart', onParticleInteract);
document.getElementById('particleSection').addEventListener('click', onParticleInteract);

// Animation loop
function animate() {
    ctx.clearRect(0, 0, W, H);
    
    particles.forEach(p => {
        ctx.fillStyle = '#f00';
        
        switch(phase) {
            case 'clumped':
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'scatter':
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'swirl':
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const angle = Math.atan2(dy, dx);
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                p.vx += -Math.sin(angle)*0.5;
                p.vy += Math.cos(angle)*0.5;
                
                const pull = (200 - dist)*0.002;
                if (pull > 0) {
                    p.vx -= dx*pull;
                    p.vy -= dy*pull;
                }
                
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.x += p.vx;
                p.y += p.vy;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
                
            case 'form':
                const target = textPoints[p.targetIndex];
                const tdx = target.x - p.x;
                const tdy = target.y - p.y;
                p.vx += tdx*0.02;
                p.vy += tdy*0.02;
                p.vx *= 0.8;
                p.vy *= 0.8;
                p.x += p.vx;
                p.y += p.vy;
                ctx.fillRect(p.x, p.y, 2, 2);
                break;
        }
    });
    
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
